<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Ridge regression</title>

  <!-- MathJax Config -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      }
    };
  </script>

  <!-- MathJax Scripts -->
  <script type="text/javascript" async
    src="https://polyfill.io/v3/polyfill.min.js?features=es6">
  </script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Ridge regression | Pieter-Jan</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Ridge regression" />
<meta name="author" content="piinghel" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In the previous article, I introduced the low volatility factor and demonstrated how a simple volatility scaling approach can significantly boost performance. This time, I’m taking it a step further by combining multiple predictors using a multiple linear regression model. I’ll also explore key modeling choices, including normalization techniques and the choice of target variable for training." />
<meta property="og:description" content="In the previous article, I introduced the low volatility factor and demonstrated how a simple volatility scaling approach can significantly boost performance. This time, I’m taking it a step further by combining multiple predictors using a multiple linear regression model. I’ll also explore key modeling choices, including normalization techniques and the choice of target variable for training." />
<link rel="canonical" href="http://localhost:4000/quants/2025/02/09/ridge.html" />
<meta property="og:url" content="http://localhost:4000/quants/2025/02/09/ridge.html" />
<meta property="og:site_name" content="Pieter-Jan" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-02-09T00:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Ridge regression" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"piinghel"},"dateModified":"2025-02-09T00:00:00+01:00","datePublished":"2025-02-09T00:00:00+01:00","description":"In the previous article, I introduced the low volatility factor and demonstrated how a simple volatility scaling approach can significantly boost performance. This time, I’m taking it a step further by combining multiple predictors using a multiple linear regression model. I’ll also explore key modeling choices, including normalization techniques and the choice of target variable for training.","headline":"Ridge regression","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/quants/2025/02/09/ridge.html"},"url":"http://localhost:4000/quants/2025/02/09/ridge.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Pieter-Jan" />
</head>
</head>

<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Pieter-Jan</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
    <div class="wrapper">
      <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Ridge regression</h1>
    <p class="post-meta"><time class="dt-published" datetime="2025-02-09T00:00:00+01:00" itemprop="datePublished">
        Feb 9, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><a href="https://piinghel.github.io/quant/2024/12/15/low-volatility-factor.html">In the previous article</a>, I introduced the low volatility factor and demonstrated how a simple volatility scaling approach can significantly boost performance. This time, I’m taking it a step further by combining multiple predictors using a multiple linear regression model. I’ll also explore key modeling choices, including normalization techniques and the choice of target variable for training.</p>

<p>Constructing effective stock selection models involves handling the wide variability in stock prices, volumes, and risk profiles. The goal is to rank stocks by their relative performance over the next period (e.g., 20 days), which makes normalization a critical step. By integrating multiple predictors and testing various modeling approaches, this article highlights and explores how including more predictors, different preprocessing methods and the choice of the target variable affects overall strategy performance.</p>

<h2 id="feature-engineering">Feature Engineering</h2>

<p>An important point is that we let the model, in this case a linear regression model, define the form of relationships. Since we use a linear model, we limit ourselves to linear relationships and do not include interaction terms for now. Obviously, we need to define our predictive features and also choose a target variable. For the predictive features, we focus on price, volume, market capitalization, and market derived features. To make this more concrete, we compute the following families of features for every stock (around 3300) in our universe:</p>

<ol>
  <li><strong>Momentum Features</strong>
    <ul>
      <li>Captures the trend-following behavior of stocks.</li>
      <li>Examples:
        <ul>
          <li>Lagged returns over short horizons (e.g., 1 to 10 days).</li>
          <li>Rolling cumulative returns over longer windows (e.g., 21 to 252 days).</li>
          <li>Moving Average Convergence Divergence (MACD) to identify shifts in momentum.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Volatility Features</strong>
    <ul>
      <li>Focuses on the risk profile of stocks.</li>
      <li>Examples:
        <ul>
          <li>Rolling historical volatility computed over time windows (e.g., 21, 63, or 126 days).</li>
          <li>Downside and upside volatility, separating negative and positive deviations in price.</li>
          <li>Average True Range (ATR) for a normalized measure of price range volatility.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Liquidity Features</strong>
    <ul>
      <li>Assesses trading activity.</li>
      <li>Examples:
        <ul>
          <li>Rolling mean and standard deviation of adjusted trading volume.</li>
          <li>Ratio of current volume to its rolling maximum to highlight unusual trading activity.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Size Features</strong>
    <ul>
      <li>Measures the size of a stock using market capitalization.</li>
      <li>Examples:
        <ul>
          <li>Rolling transformations of market cap, such as mean and minimum values over time.</li>
          <li>Helps differentiate between small-cap and large-cap stocks.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Short Mean Reversion Features</strong>
    <ul>
      <li>Identifies conditions where prices revert to a historical mean.</li>
      <li>Examples:
        <ul>
          <li>Deviation of the price from its rolling moving average.</li>
          <li>Price position relative to rolling minimum or maximum values.</li>
          <li>Bollinger Bands to highlight overbought or oversold conditions.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Correlation with the Market</strong>
    <ul>
      <li>Captures the systematic risk of a stock by measuring its relationship with the market index.</li>
      <li>Examples:
        <ul>
          <li>Rolling correlation with the Russell 1000 over time windows (e.g., 63 days).</li>
          <li>Useful for identifying defensive stocks or those with high beta.</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p>In total we have around 150 predictive features, some of them will be very correlated obviously. Next is determining our target variable. I will focus on predicting the return for the next 20 days and predicting the sharpe ratio for the next 20 days. Obviously we could epxlore different periods as well but for the sake of simplicity let’s keep it at 20 days.</p>

<h2 id="preprocessing-steps">Preprocessing Steps</h2>

<p>An important step in this process is normalizing the data. To understand why this is necessary, let’s take a step back. The goal is to identify, for each period (e.g., each day), the stocks that are most likely to perform well. We define “performing well” as having the highest return or Sharpe ratio over the next 20 days.</p>

<p>Think of it as creating a ranking: we want to push the best-performing stocks to the top of the list and the worst-performing stocks to the bottom. This means we’re not focused on the actual numbers (like the exact return or Sharpe ratio of each stock); instead, we care about how each stock compares to the others. The problem is relative by nature we want to know if stock A is likely to do better than stock B in terms of sharpe ratio.</p>

<p>To simplify the problem, we normalize the data for each day across all stocks. This process, called cross-sectional normalization, adjusts the predictive features and the target variable so they are on a consistent scale. For example, this could involve scaling the values to have a mean of zero and a standard deviation of one also know as Z-scoring. By doing this, we make it easier for the model to compare stocks and focus on their relative rankings, rather than being influenced by differences in scale or magnitude.</p>

<p>I will compare the following normalization methods:</p>

<ol>
  <li><strong>No normalization (Raw):</strong> Used as a baseline to compare the performance of other methods.</li>
  <li><strong>Ranking and mapping to a range (0 to 100):</strong> The lowest value is mapped to 0, and the highest value is mapped to 100.</li>
  <li><strong>Z-scoring:</strong> Values are normalized to have a mean of 0 and a standard deviation of 1. To handle outliers, we clip values greater than 5 or less than -5 to 5 and -5, respectively.</li>
</ol>

<p>Ranking maps all values to a uniform distribution, making the data stationary and naturally handling outliers. This method increases stability by compressing all values into a fixed range, but it also has a downside: some information is lost because the values are “squeezed” into the interval. Z-scoring, on the other hand, provides more freedom by preserving the magnitude of differences between values, while still managing outliers with clipping.</p>

<p>Finally, we will compare one additional approach:</p>

<ul>
  <li><strong>Sector-specific ranking of the target variable:</strong> The target variable is ranked within each sector, which is similar to making your stock selection sector-neutral.</li>
</ul>

<p>These comparisons will help us understand the trade-offs and advantages of different normalization methods.</p>

<p>For missing data, we use the following logic. We start with doing forward fill, when forward fill is not an option, meaning there are no pevious data points. We will using the cross sectional mean by from the others stock in the same sector for that specific date. When this is not an option, I will impute just by the mean after normalizing the data;  0 for z scoring and 50 for ranking. Obviously this topic on it’s own deserved a whole post on itself as it’s important and many possibility better approaches exist.</p>

<h2 id="model-and-validation-procedure">Model and Validation Procedure</h2>

<h3 id="generalized-prediction-framework">Generalized Prediction Framework</h3>

<p>To fixate the problem, we model the score or ranking of a stock (which can be its <strong>Sharpe ratio, return, or another performance measure</strong>) using an additive prediction error model:</p>

\[s_{i,t+1} = \mathbb{E}_t[s_{i,t+1}] + \epsilon_{i,t+1},\]

<p>where</p>

\[\mathbb{E}_t[s_{i,t+1}] = g(\mathbf{z}_{i,t}).\]

<p>Stocks are indexed as $i = 1,…,N_t$ and time periods as $t = 1,…,T$. We assume a balanced panel for simplicity, deferring missing data handling to the preprocessing section.</p>

<p>The objective is to model \(\mathbb{E}_t[s_{i,t+1}]\), the <strong>expected ranking score</strong> of a stock, as a function of its predictor variables. We denote the predictors as the $P$-dimensional vector $\mathbf{z}_{i,t}$, where $g(\cdot)$ is a flexible function mapping these predictors to expected rankings.</p>

<p>In this framework, the function $g(\cdot)$ has two key characteristics:</p>

<ul>
  <li>
    <p><strong>Consistency across stocks and time periods</strong>: The function $g(\cdot)$ does not vary based on the specific stock $i$ or time $t$; it maintains the same form for all stocks and periods. By leveraging information from the entire panel, the model stabilizes ranking estimates, ensuring that the function behaves uniformly across the data.</p>
  </li>
  <li>
    <p><strong>Dependence only on \(\mathbf{z}_{i,t}\)</strong>: The function $g(\cdot)$ relies on the feature vector $ \mathbf{z}_{i,t} $ for each stock $i$ at time $t$, and does not explicitly incorporate information from previous periods or from other stocks. While lagged features are included in the model, the function avoids direct dependencies on past data or cross-stock information.</p>
  </li>
</ul>

<p>We approximate $g(\cdot)$ using <strong>Ridge Regression</strong>, a linear model that is particularly useful when predictors are highly correlated.</p>

<h3 id="motivation-for-using-ridge-regression">Motivation for Using Ridge Regression</h3>

<p>Before moving on to the validation procedure, let’s briefly highlight why Ridge Regression is well-suited for our approach:</p>

<ul>
  <li>It is particularly useful in high-dimensional settings or when predictors are highly correlated, as it mitigates multicollinearity.</li>
  <li>The $L_2$ penalty prevents extreme coefficient values, leading to a more stable and generalizable model.</li>
  <li>It helps balance bias and variance, reducing overfitting while preserving important predictive relationships.</li>
</ul>

<p>The ridge regression loss function is:</p>

\[\text{Minimize: } \frac{1}{n} \sum_{i=1}^n (y_i - \mathbf{x}_i^\top \boldsymbol{\beta})^2 + \lambda \sum_{j=1}^p \beta_j^2\]

<p>With these advantages in mind, we now turn to the validation procedure, where we train the model and assess its performance.</p>

<h3 id="expanding-walkforward-validation-procedure">Expanding Walkforward Validation Procedure</h3>

<p>To test and improve the ridge regression model, we use an <strong>expanding walkforward validation procedure</strong>. It starts with a 3-year burn-in period. After that, the model is updated about every 2 years using all the data available up to that point. This way, the model keeps learning from new data while using the full history for better predictions.</p>

<p>In my experience, using an <strong>expanding walkforward approach</strong>, which includes all available data, works better than rolling validation methods. Rolling validation only uses recent data and may miss important long-term patterns, leading to less stable predictions. The expanding method allows the model to use more data, which helps it find these patterns and make more reliable predictions.</p>

<p>You can also choose to <strong>split the training data into a train and validation set</strong> within each period if you want to do hyperparameter tuning. This isn’t required for all cases, but it can help fine-tune the model before testing it, making it more accurate.</p>

<p>Below is a detailed representation of the expanding walkforward procedure:</p>

<p><img src="/assets/ridge/walk-forward.png" alt="Figure 1" /></p>

<p><strong>Figure 1</strong>: schematic overview of an expanding walk forward procedure.</p>

<h2 id="portfolio-construction">Portfolio Construction</h2>

<p>We use the same portfolio allocation model as in  <a href="https://piinghel.github.io/quant/2024/12/15/low-volatility-factor.html">our previous article</a>. The strategy ranks stocks based on the model’s rankings, selecting the top 75 stocks to go long and the bottom 75 to go short.</p>

<p>To ensure the risk is balanced, we apply a volatility targeting approach. This approach adjusts the weights of stocks according to their risk profile to ensure that each stock within the portfolio contributes approximately the same amount of risk. This way, we achieve a balanced portfolio with consistent risk across the long and short portfolio.</p>

<p>By combining the model’s rankings with a risk-targeting strategy, we create a portfolio that is both well-diversified and dynamically adjust its risk over time.</p>

<h2 id="results">Results</h2>

<p>To analyze the impact of different modeling choices, I have plotted the cumulative returns of all strategies, rescaled to a volatility of 8% (Figure 2). This ensures a fair comparison by normalizing risk levels across strategies.</p>

<p>In total, we evaluate 10 different modeling choices, combining 5 normalization methods (Unprocessed, Z-score overall, Ranking overall, Z-score by sector, and Ranking by sector) with 2 target labels (SR 20 and Return 20). The goal is to assess how both the normalization approach and the choice of target label influence performance.</p>

<p>For now, I’ve left the strategy labels out—let’s keep some tension before diving into the details. As you can see, there is quite a bit of variation in performance across the different approaches. Below, I present the results and key insights into how these modeling choices affect strategy returns.</p>

<p><img src="/assets/ridge/all_lines.png" alt="Figure 2" /></p>

<p><strong>Figure 2</strong>: Performance of all different modelling choices. All lines are scaled to the same level of volatility.</p>

<p>Figure 2 explores the impact of different modeling choices on performance, measured in terms of Sharpe ratio. The first comparison looks at normalization methods, evaluating whether ranking, raw values, or z-scoring lead to better results. The second focuses on whether normalization is applied globally or within sectors. The final comparison examines whether training the model on return or Sharpe ratio yields superior outcomes.</p>

<p>The results make one thing clear: ranking within sectors and training the model on Sharpe ratio consistently lead to the best performance. However, the impact of the normalization method itself is less obvious. I initially expected both z-scoring and ranking to outperform raw normalization, but the results don’t show a decisive advantage for either approach.</p>

<p>To dig deeper, Figure 3 provides a more granular view by conditioning performance on the target label. Interestingly, when training on Sharpe ratio, both ranking and z-scoring produce significantly stronger results compared to raw normalization. However, when training on return, z-scoring surprisingly performs the worst, while ranking remains a strong choice.</p>

<p>This contrast suggests that the effectiveness of a normalization method depends heavily on the modeling objective. While z-scoring improves performance when optimizing for Sharpe ratio, it seems detrimental when the model is trained on return. Ranking, on the other hand, appears to be a robust choice across both scenarios, making it a reliable default.</p>

<p><img src="/assets/ridge/summary_barplot.png" alt="Figure 3" /></p>

<p><strong>Figure 3</strong>: Sharpe Ratio Performance Across Key Modeling Choices.</p>

<p><img src="/assets/ridge/normalization_target.png" alt="Figure 4" /></p>

<p><strong>Figure 4</strong>: Cumulative return of different normalization methods conditioned on the target label. Performance are scaled to the same level of volatility.</p>

<table>
  <thead>
    <tr>
      <th>Model</th>
      <th>Return (ann. %)</th>
      <th>Volatility (ann. %)</th>
      <th>Sharpe Ratio (ann.)</th>
      <th>Maximum Drawdown (%)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>sr_zscore_by_sector</td>
      <td>10.8</td>
      <td>8.1</td>
      <td>1.3</td>
      <td>12.6</td>
    </tr>
    <tr>
      <td>combo</td>
      <td>8.4</td>
      <td>6.7</td>
      <td>1.3</td>
      <td>13.4</td>
    </tr>
    <tr>
      <td>sr_ranking_by_sector</td>
      <td>9.8</td>
      <td>8.0</td>
      <td>1.2</td>
      <td>12.9</td>
    </tr>
    <tr>
      <td>sr_zscore_globally</td>
      <td>10.1</td>
      <td>8.6</td>
      <td>1.2</td>
      <td>19.0</td>
    </tr>
    <tr>
      <td>sr_ranking_globally</td>
      <td>9.3</td>
      <td>8.5</td>
      <td>1.1</td>
      <td>16.9</td>
    </tr>
    <tr>
      <td>sr_raw_globally</td>
      <td>8.9</td>
      <td>8.5</td>
      <td>1.1</td>
      <td>16.1</td>
    </tr>
    <tr>
      <td>return_ranking_by_sector</td>
      <td>7.6</td>
      <td>7.6</td>
      <td>1.0</td>
      <td>14.9</td>
    </tr>
    <tr>
      <td>return_raw_globally</td>
      <td>7.2</td>
      <td>7.3</td>
      <td>1.0</td>
      <td>16.7</td>
    </tr>
    <tr>
      <td>return_ranking_globally</td>
      <td>7.5</td>
      <td>7.7</td>
      <td>1.0</td>
      <td>18.4</td>
    </tr>
    <tr>
      <td>return_zscore_by_sector</td>
      <td>6.6</td>
      <td>7.4</td>
      <td>0.9</td>
      <td>20.1</td>
    </tr>
    <tr>
      <td>return_zscore_globally</td>
      <td>5.5</td>
      <td>7.5</td>
      <td>0.7</td>
      <td>21.0</td>
    </tr>
  </tbody>
</table>

<p><strong>Table 1</strong>: Statistics of all different modelling choices. Ranked in ascending order based on sharpe ratio.</p>

<h2 id="todo">TODO</h2>
<ul>
  <li>results be a bit more in detail about the performance</li>
  <li>Add flowchart for walkfroward; explain it a bit more that you can do an extra validation procedure</li>
  <li>Maybe add the normaliation a bit more clear with a fomula</li>
  <li>Conclude</li>
</ul>

  </div><a class="u-url" href="/quants/2025/02/09/ridge.html" hidden></a>
</article>

    </div>
  </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="http://localhost:4000/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">piinghel</li>
          <li><a class="u-email" href="mailto:pjinghelbrecht@gmail.com">pjinghelbrecht@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Systematic trading and data science things.
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
